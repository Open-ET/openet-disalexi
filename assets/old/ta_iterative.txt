
    # # DEADBEEF - Old code for iteratively computing a new Tair image
    # if iteration <= 0:
    #      # For initial iteration compute bias at 250 and 350 K
    #      a_img = d_obj.ta_coarse(ta_img=ee.Image.constant(250)) \
    #          .select(['ta', 'bias'], ['ta_a', 'bias_a'])
    #      b_img = d_obj.ta_coarse(ta_img=ee.Image.constant(350)) \
    #          .select(['ta', 'bias'], ['ta_b', 'bias_b'])
    #      # Applying both bias masks to the output
    #      # This shouldn't be necessary but ta_coarse was returning
    #      #   ta and bias images with different masks
    #      export_img = ee.Image([a_img, b_img])\
    #          .updateMask(a_img.select(['bias_a']).And(
    #              b_img.select(['bias_b'])))\
    #          .double()
    #  # elif iteration <= 4:
    #  #     # Interpolate new Ta from the bias and test directly
    #  #     # Roughly equivalent to false position method
    #  #     ta_img = ee.Image('{}/{}_{:02d}'.format(
    #  #         ta_wrs2_coll_id, scene_id, iteration - 1))
    #  #     # ta_img = ee.Image(ta_coll
    #  #     #     .filterMetadata('date', 'equals', export_date)
    #  #     #     .filterMetadata('iteration', 'equals', iteration - 1)
    #  #     #     .first())
    #  #     ta_a = ta_img.select(['ta_a'])
    #  #     ta_b = ta_img.select(['ta_b'])
    #  #     bias_a = ta_img.select(['bias_a'])
    #  #     bias_b = ta_img.select(['bias_b'])
    #  #
    #  #     ta_x = bias_a.multiply(ta_b).subtract(bias_b.multiply(ta_a))\
    #  #         .divide(bias_a.subtract(bias_b))
    #  #     bias_x = d_obj.et_bias(d_obj.et_coarse(ta_x))
    #  #
    #  #     # Use the new value if it minimizes the bias and brackets 0
    #  #     mask1 = bias_x.lt(bias_b).And(bias_x.gt(0))
    #  #     mask2 = bias_x.gt(bias_a).And(bias_x.lt(0))
    #  #     ta_b = ta_b.where(mask1, ta_x)
    #  #     bias_b = bias_b.where(mask1, bias_x)
    #  #     ta_a = ta_a.where(mask2, ta_x)
    #  #     bias_a = bias_a.where(mask2, bias_x)
    #  #     export_img = ee.Image([ta_a, bias_a, ta_b, bias_b])
    #  else:
    #      # Generate test Ta randomly from a triangular distribution
    #      # Center the distribution on the interpolated zero bias Ta
    #      ta_img = ee.Image('{}/{}_{:02d}'.format(
    #          ta_wrs2_coll_id, scene_id, iteration - 1))
    #      # ta_img = ee.Image(ta_coll
    #      #     .filterMetadata('date', 'equals', export_date)
    #      #     .filterMetadata('iteration', 'equals', iteration - 1)
    #      #     .first())
    #      ta_a = ta_img.select(['ta_a'])
    #      ta_b = ta_img.select(['ta_b'])
    #      bias_a = ta_img.select(['bias_a'])
    #      bias_b = ta_img.select(['bias_b'])
    #
    #      ta_c = bias_a.multiply(ta_b).subtract(bias_b.multiply(ta_a))\
    #          .divide(bias_a.subtract(bias_b))
    #      # ta_c = ta_a.add(ta_b).multiply(0.5)
    #
    #      # For now use a single random number for the whole scene
    #      # Need to check if ee.Image.random() will work though
    #      u = ta_b.multiply(0).add(random.random())
    #      # u = ta_b.multiply(0).add(ee.Image.random(0))
    #
    #      a = u.multiply(ta_b.subtract(ta_a))\
    #          .multiply(ta_c.subtract(ta_a)).sqrt().add(ta_a)
    #      b = u.multiply(-1).add(1)\
    #          .multiply(ta_b.subtract(ta_a))\
    #          .multiply(ta_b.subtract(ta_c))\
    #          .sqrt().multiply(-1).add(ta_b)
    #      fc = ta_c.subtract(ta_a).divide(ta_b.subtract(ta_a))
    #      ta_x = a.where(u.gt(fc), b)
    #      bias_x = d_obj.et_bias(d_obj.et_coarse(ta_x))
    #
    #      # Use the new value if it minimizes the bias and brackets 0
    #      mask1 = bias_x.lt(bias_b).And(bias_x.gt(0))
    #      mask2 = bias_x.gt(bias_a).And(bias_x.lt(0))
    #      ta_b = ta_b.where(mask1, ta_x)
    #      bias_b = bias_b.where(mask1, bias_x)
    #      ta_a = ta_a.where(mask2, ta_x)
    #      bias_a = bias_a.where(mask2, bias_x)
    #      export_img = ee.Image([ta_a, bias_a, ta_b, bias_b])
    #
    #  # else:
    #  #     ta_img = ee.Image('{}/{}_{}'.format(
    #  #         ta_wrs2_coll_id, scene_id, iteration - 1))
    #  #     # ta_img = ee.Image(ta_coll
    #  #     #     .filterMetadata('date', 'equals', export_date)
    #  #     #     .filterMetadata('iteration', 'equals', iteration - 1)
    #  #     #     .first())
    #  #     ta_a = ta_img.select(['ta_a'])
    #  #     ta_b = ta_img.select(['ta_b'])
    #  #     bias_a = ta_img.select(['bias_a'])
    #  #     bias_b = ta_img.select(['bias_b'])
    #  #     # abs_a = ta_img.select(['bias_a']).abs()
    #  #     # abs_b = ta_img.select(['bias_b']).abs()
    #  #
    #  #     # Compute new test Ta and biases
    #  #     ta_c = ta_b.subtract(ta_b.subtract(ta_a).multiply(0.618034))
    #  #     ta_d = ta_a.add(ta_b.subtract(ta_a).multiply(0.618034))
    #  #     bias_c = d_obj.et_bias(d_obj.et_coarse(ta_c))
    #  #     bias_d = d_obj.et_bias(d_obj.et_coarse(ta_d))
    #  #     abs_c = bias_c.abs()
    #  #     abs_d = bias_d.abs()
    #  #
    #  #     # Use the new values if they minimize the bias
    #  #     # If f(c) < f(d): move the data from d to b and c to d
    #  #     mask1 = abs_c.lt(abs_d)
    #  #     # If f(c) > f(d): move the data from c to a and d to c
    #  #     mask2 = abs_c.gte(abs_d)
    #  #     ta_b = ta_b.where(mask1, ta_d)
    #  #     bias_b = bias_b.where(mask1, bias_d)
    #  #     ta_a = ta_a.where(mask2, ta_c)
    #  #     bias_a = bias_a.where(mask2, bias_c)
    #  #
    #  #     export_img = ee.Image([ta_a, bias_a, ta_b, bias_b])